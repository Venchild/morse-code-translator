// Language translations - 모든 언어 완성
const translations = {
    en: {
        title: "MOST - Morse Code Translator",
        subtitle: "Real-time translation between text and Morse code",
        inputLabel: "Enter text to translate",
        outputLabel: "Morse Code Output",
        modeTextToMorse: "Text → Morse",
        modeMorseToText: "Morse → Text",
        playText: "Play",
        copyText: "Copy",
        clearText: "Clear",
        shareText: "Share",
        shareTitle: "Share this translation",
        copyUrlText: "Copy URL",
        downloadTitle: "Want more features?",
        downloadDescription: "Download the full app to access Timeline community features, save your translations, and connect with other users!",
        downloadText: "Download on Google Play",
        speedLabel: "Speed:",
        detectedLang: "Detected language: ",
        placeholder: "Type your message here...",
        morsePlaceholder: "Enter Morse code here (use . for dot, - for dash)...",
        referenceText: "Code Reference",
        modalTitle: "Morse Code Reference"
    },
    ko: {
        title: "MOST - 모스 부호 번역기",
        subtitle: "텍스트와 모스 부호 간 실시간 번역",
        inputLabel: "번역할 텍스트 입력",
        outputLabel: "모스 부호 출력",
        modeTextToMorse: "텍스트 → 모스",
        modeMorseToText: "모스 → 텍스트",
        playText: "재생",
        copyText: "복사",
        clearText: "지우기",
        shareText: "공유",
        shareTitle: "이 번역 공유하기",
        copyUrlText: "URL 복사",
        downloadTitle: "더 많은 기능이 필요하세요?",
        downloadDescription: "전체 앱을 다운로드하여 타임라인 커뮤니티 기능, 번역 저장, 다른 사용자와의 연결을 이용하세요!",
        downloadText: "Google Play에서 다운로드",
        speedLabel: "속도:",
        detectedLang: "감지된 언어: ",
        placeholder: "여기에 메시지를 입력하세요...",
        morsePlaceholder: "모스 부호를 입력하세요 (점은 ., 선은 -)...",
        referenceText: "코드 참조",
        modalTitle: "모스 부호 참조표"
    },
    ja: {
        title: "MOST - モールス符号翻訳機",
        subtitle: "テキストとモールス符号のリアルタイム翻訳",
        inputLabel: "翻訳するテキストを入力",
        outputLabel: "モールス符号出力",
        modeTextToMorse: "テキスト → モールス",
        modeMorseToText: "モールス → テキスト",
        playText: "再生",
        copyText: "コピー",
        clearText: "クリア",
        shareText: "共有",
        shareTitle: "この翻訳を共有",
        copyUrlText: "URLをコピー",
        downloadTitle: "もっと機能が欲しいですか？",
        downloadDescription: "完全版アプリをダウンロードして、タイムラインコミュニティ機能、翻訳の保存、他のユーザーとの接続をお楽しみください！",
        downloadText: "Google Playでダウンロード",
        speedLabel: "速度:",
        detectedLang: "検出された言語: ",
        placeholder: "ここにメッセージを入力してください...",
        morsePlaceholder: "モールス符号を入力してください (ドットは .、ダッシュは -)...",
        referenceText: "符号表",
        modalTitle: "モールス符号表"
    },
    zh: {
        title: "MOST - 摩尔斯电码翻译器",
        subtitle: "文本与摩尔斯电码的实时翻译",
        inputLabel: "输入要翻译的文本",
        outputLabel: "摩尔斯电码输出",
        modeTextToMorse: "文本 → 摩尔斯",
        modeMorseToText: "摩尔斯 → 文本",
        playText: "播放",
        copyText: "复制",
        clearText: "清除",
        shareText: "分享",
        shareTitle: "分享此翻译",
        copyUrlText: "复制链接",
        downloadTitle: "需要更多功能？",
        downloadDescription: "下载完整应用以访问时间线社区功能、保存翻译并与其他用户连接！",
        downloadText: "在Google Play下载",
        speedLabel: "速度：",
        detectedLang: "检测到的语言：",
        placeholder: "在此输入您的消息...",
        morsePlaceholder: "在此输入摩尔斯电码（用.表示点，-表示划）...",
        referenceText: "电码表",
        modalTitle: "摩尔斯电码表"
    },
    es: {
        title: "MOST - Traductor de Código Morse",
        subtitle: "Traducción en tiempo real entre texto y código Morse",
        inputLabel: "Ingrese el texto a traducir",
        outputLabel: "Salida de Código Morse",
        modeTextToMorse: "Texto → Morse",
        modeMorseToText: "Morse → Texto",
        playText: "Reproducir",
        copyText: "Copiar",
        clearText: "Limpiar",
        shareText: "Compartir",
        shareTitle: "Compartir esta traducción",
        copyUrlText: "Copiar URL",
        downloadTitle: "¿Quieres más funciones?",
        downloadDescription: "¡Descarga la aplicación completa para acceder a las funciones de la comunidad Timeline, guardar tus traducciones y conectar con otros usuarios!",
        downloadText: "Descargar en Google Play",
        speedLabel: "Velocidad:",
        detectedLang: "Idioma detectado: ",
        placeholder: "Escriba su mensaje aquí...",
        morsePlaceholder: "Ingrese código Morse aquí (use . para punto, - para raya)...",
        referenceText: "Tabla de Códigos",
        modalTitle: "Tabla de Código Morse"
    },
    fr: {
        title: "MOST - Traducteur de Code Morse",
        subtitle: "Traduction en temps réel entre texte et code Morse",
        inputLabel: "Saisissez le texte à traduire",
        outputLabel: "Sortie du Code Morse",
        modeTextToMorse: "Texte → Morse",
        modeMorseToText: "Morse → Texte",
        playText: "Jouer",
        copyText: "Copier",
        clearText: "Effacer",
        shareText: "Partager",
        shareTitle: "Partager cette traduction",
        copyUrlText: "Copier l'URL",
        downloadTitle: "Vous voulez plus de fonctionnalités?",
        downloadDescription: "Téléchargez l'application complète pour accéder aux fonctionnalités de la communauté Timeline, sauvegarder vos traductions et vous connecter avec d'autres utilisateurs!",
        downloadText: "Télécharger sur Google Play",
        speedLabel: "Vitesse:",
        detectedLang: "Langue détectée: ",
        placeholder: "Tapez votre message ici...",
        morsePlaceholder: "Entrez le code Morse ici (utilisez . pour point, - pour tiret)...",
        referenceText: "Table des Codes",
        modalTitle: "Table du Code Morse"
    },
    de: {
        title: "MOST - Morsecode-Übersetzer",
        subtitle: "Echtzeit-Übersetzung zwischen Text und Morsecode",
        inputLabel: "Text zum Übersetzen eingeben",
        outputLabel: "Morsecode-Ausgabe",
        modeTextToMorse: "Text → Morse",
        modeMorseToText: "Morse → Text",
        playText: "Abspielen",
        copyText: "Kopieren",
        clearText: "Löschen",
        shareText: "Teilen",
        shareTitle: "Diese Übersetzung teilen",
        copyUrlText: "URL kopieren",
        downloadTitle: "Möchten Sie mehr Funktionen?",
        downloadDescription: "Laden Sie die vollständige App herunter, um auf Timeline-Community-Funktionen zuzugreifen, Ihre Übersetzungen zu speichern und sich mit anderen Benutzern zu verbinden!",
        downloadText: "Bei Google Play herunterladen",
        speedLabel: "Geschwindigkeit:",
        detectedLang: "Erkannte Sprache: ",
        placeholder: "Geben Sie hier Ihre Nachricht ein...",
        morsePlaceholder: "Geben Sie hier Morsecode ein (verwenden Sie . für Punkt, - für Strich)...",
        referenceText: "Code-Tabelle",
        modalTitle: "Morsecode-Tabelle"
    },
    ru: {
        title: "MOST - Переводчик азбуки Морзе",
        subtitle: "Перевод в реальном времени между текстом и азбукой Морзе",
        inputLabel: "Введите текст для перевода",
        outputLabel: "Вывод азбуки Морзе",
        modeTextToMorse: "Текст → Морзе",
        modeMorseToText: "Морзе → Текст",
        playText: "Воспроизвести",
        copyText: "Копировать",
        clearText: "Очистить",
        shareText: "Поделиться",
        shareTitle: "Поделиться этим переводом",
        copyUrlText: "Копировать URL",
        downloadTitle: "Хотите больше функций?",
        downloadDescription: "Загрузите полное приложение для доступа к функциям сообщества Timeline, сохранения переводов и связи с другими пользователями!",
        downloadText: "Скачать в Google Play",
        speedLabel: "Скорость:",
        detectedLang: "Обнаруженный язык: ",
        placeholder: "Введите ваше сообщение здесь...",
        morsePlaceholder: "Введите азбуку Морзе здесь (используйте . для точки, - для тире)...",
        referenceText: "Таблица Кодов",
        modalTitle: "Таблица Азбуки Морзе"
    },
    ar: {
        title: "MOST - مترجم شفرة مورس",
        subtitle: "ترجمة فورية بين النص وشفرة مورس",
        inputLabel: "أدخل النص للترجمة",
        outputLabel: "مخرجات شفرة مورس",
        modeTextToMorse: "نص ← مورس",
        modeMorseToText: "مورس ← نص",
        playText: "تشغيل",
        copyText: "نسخ",
        clearText: "مسح",
        shareText: "مشاركة",
        shareTitle: "مشاركة هذه الترجمة",
        copyUrlText: "نسخ الرابط",
        downloadTitle: "تريد المزيد من الميزات؟",
        downloadDescription: "قم بتنزيل التطبيق الكامل للوصول إلى ميزات مجتمع الخط الزمني وحفظ ترجماتك والتواصل مع المستخدمين الآخرين!",
        downloadText: "تنزيل من Google Play",
        speedLabel: "السرعة:",
        detectedLang: "اللغة المكتشفة: ",
        placeholder: "اكتب رسالتك هنا...",
        morsePlaceholder: "أدخل شفرة مورس هنا (استخدم . للنقطة، - للشرطة)...",
        referenceText: "جدول الشفرات",
        modalTitle: "جدول شفرة مورس"
    }
};

// Morse code mappings organized by language/script
const morseCodeTables = {
    latin: {
        title: "Latin Alphabet & Numbers",
        codes: {
            'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.',
            'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..',
            'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.',
            'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-',
            'Y': '-.--', 'Z': '--..', 
            '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-',
            '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.'
        }
    },
    korean: {
        title: "Korean (한글)",
        codes: {
            // Basic consonants
            'ㄱ': '.-.', 'ㄴ': '..-.', 'ㄷ': '-..', 'ㄹ': '...-', 'ㅁ': '--',
            'ㅂ': '.--', 'ㅅ': '--.', 'ㅇ': '-.-', 'ㅈ': '.---.', 'ㅊ': '-.-.', 
            'ㅋ': '-..-', 'ㅌ': '--..', 'ㅍ': '---', 'ㅎ': '.---',
            // Basic vowels
            'ㅏ': '.', 'ㅑ': '..', 'ㅓ': '-', 'ㅕ': '...', 'ㅗ': '.--', 
            'ㅛ': '-.', 'ㅜ': '....', 'ㅠ': '.-.', 'ㅡ': '-..-', 'ㅣ': '..-',
            // Complex consonants
            'ㄲ': '.-.-.', 'ㄸ': '-..-.', 'ㅃ': '.--.',
            'ㅆ': '--.-', 'ㅉ': '.---.',
            // Complex vowels
            'ㅐ': '.--', 'ㅒ': '..--', 'ㅔ': '-.--', 'ㅖ': '...--',
            'ㅘ': '.---', 'ㅙ': '.----', 'ㅚ': '.--.-',
            'ㅝ': '....--', 'ㅞ': '....---', 'ㅟ': '....-',
            'ㅢ': '..-.-'
        }
    },
    japanese: {
        title: "Japanese (カタカナ)",
        codes: {
            'ア': '--.-', 'イ': '.-', 'ウ': '..-', 'エ': '-.---', 'オ': '.-...',
            'カ': '.-..', 'キ': '-.-.', 'ク': '...-', 'ケ': '-.--', 'コ': '----',
            'サ': '-.-.-', 'シ': '--.-', 'ス': '---.-', 'セ': '.---.', 'ソ': '---.',
            'タ': '-', 'チ': '..-.', 'ツ': '.--', 'テ': '.-.--', 'ト': '..-..',
            'ナ': '.-.', 'ニ': '-.-.', 'ヌ': '....', 'ネ': '--.-', 'ノ': '..--',
            'ハ': '-...', 'ヒ': '--..-', 'フ': '--..', 'ヘ': '.', 'ホ': '-..',
            'マ': '-..-', 'ミ': '..-.-', 'ム': '-', 'メ': '-...-', 'モ': '-..-',
            'ヤ': '.--', 'ユ': '-..--', 'ヨ': '--',
            'ラ': '...', 'リ': '--.', 'ル': '-.--', 'レ': '---', 'ロ': '.-.-',
            'ワ': '-.-', 'ヲ': '.---', 'ン': '.-.-.'
        }
    },
    cyrillic: {
        title: "Cyrillic (Русский)",
        codes: {
            'А': '.-', 'Б': '-...', 'В': '.--', 'Г': '--.', 'Д': '-..',
            'Е': '.', 'Ж': '...-', 'З': '--..', 'И': '..', 'Й': '.---',
            'К': '-.-', 'Л': '.-..', 'М': '--', 'Н': '-.', 'О': '---',
            'П': '.--.', 'Р': '.-.', 'С': '...', 'Т': '-', 'У': '..-',
            'Ф': '..-.', 'Х': '....', 'Ц': '-.-.', 'Ч': '---.', 'Ш': '----',
            'Щ': '--.-', 'Ъ': '.--.-.', 'Ы': '-.--', 'Ь': '-..-', 'Э': '..-.',
            'Ю': '..--', 'Я': '.-.-'
        }
    },
    arabic: {
        title: "Arabic (العربية)",
        codes: {
            'ا': '.-', 'ب': '-...', 'ت': '-', 'ث': '-.-.', 'ج': '.---',
            'ح': '....', 'خ': '---', 'د': '-..', 'ذ': '--..', 'ر': '.-.',
            'ز': '---', 'س': '...', 'ش': '----', 'ص': '-..-', 'ض': '...-',
            'ط': '..-', 'ظ': '-.--', 'ع': '.-.-', 'غ': '--.', 'ف': '..-.',
            'ق': '--.-', 'ك': '-.-', 'ل': '.-..', 'م': '--', 'ن': '-.',
            'ه': '.....', 'و': '.--', 'ي': '..'
        }
    },
    punctuation: {
        title: "Punctuation & Special",
        codes: {
            '.': '.-.-.-', ',': '--..--', '?': '..--..', "'": '.----.', 
            '!': '-.-.--', '/': '-..-.', '(': '-.--.', ')': '-.--.-',
            '&': '.-...', ':': '---...', ';': '-.-.-.', '=': '-...-',
            '+': '.-.-.', '-': '-....-', '_': '..--.-', '"': '.-..-.',
            '$': '...-..-', '@': '.--.-', ' ': '/'
        }
    }
};

// Combined morse code mapping for translation
const morseCode = {};
Object.values(morseCodeTables).forEach(table => {
    Object.assign(morseCode, table.codes);
});

// Reverse mapping for decoding
const reverseMorseCode = {};
Object.keys(morseCode).forEach(key => {
    reverseMorseCode[morseCode[key]] = key;
});

// Language detection patterns
const languagePatterns = {
    ko: /[ㄱ-ㅎㅏ-ㅣ가-힣]/,
    ja: /[ひらがなカタカナ一-龯]/,
    zh: /[\u4e00-\u9fff]/,
    ru: /[а-яё]/i,
    ar: /[\u0600-\u06ff]/,
    en: /^[a-zA-Z0-9\s.,!?'"()-]+$/
};

// Current state
let currentLang = 'en';
let isTextToMorse = true;
let audioContext;
let isPlaying = false;
let currentOscillator = null;
let currentToneTimeout = null;

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    init();
});

function init() {
    console.log('Initializing app...');
    detectUserLanguage();
    setupEventListeners();
    updateUI();
    createParticles();
    loadFromURL();
    
    // 초기 샘플 텍스트
    setTimeout(() => {
        if (!document.getElementById('inputArea').value) {
            document.getElementById('inputArea').value = 'Hello World';
            translateText();
        }
    }, 1000);
}

function detectUserLanguage() {
    const userLang = navigator.language.split('-')[0];
    console.log('Detected browser language:', userLang);
    if (translations[userLang]) {
        currentLang = userLang;
        const langName = getLanguageName(userLang);
        console.log('Setting language to:', langName);
        document.getElementById('currentLang').textContent = langName;
    }
}

function getLanguageName(lang) {
    const names = {
        en: '🇺🇸 English',
        ko: '🇰🇷 한국어',
        ja: '🇯🇵 日本語',
        zh: '🇨🇳 中文',
        es: '🇪🇸 Español',
        fr: '🇫🇷 Français',
        de: '🇩🇪 Deutsch',
        ru: '🇷🇺 Русский',
        ar: '🇸🇦 العربية'
    };
    return names[lang] || '🇺🇸 English';
}

function setupEventListeners() {
    console.log('Setting up event listeners...');
    
    // Language selector - 수정된 이벤트 핸들링
    const languageBtn = document.getElementById('languageBtn');
    const languageDropdown = document.getElementById('languageDropdown');
    
    if (languageBtn && languageDropdown) {
        console.log('Language selector found, setting up events...');
        
        languageBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('Language button clicked');
            
            const isExpanded = languageDropdown.classList.contains('active');
            console.log('Dropdown is currently expanded:', isExpanded);
            
            languageDropdown.classList.toggle('active');
            languageBtn.setAttribute('aria-expanded', !isExpanded);
            
            console.log('Dropdown toggled. Active class:', languageDropdown.classList.contains('active'));
        });

        // 언어 옵션 클릭 이벤트
        document.querySelectorAll('.language-option').forEach(option => {
            option.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const lang = this.dataset.lang;
                const langText = this.textContent.trim();
                
                console.log('Language option clicked:', lang, langText);
                
                currentLang = lang;
                document.getElementById('currentLang').textContent = langText;
                languageDropdown.classList.remove('active');
                languageBtn.setAttribute('aria-expanded', 'false');
                
                updateUI();
            });
            
            option.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    this.click();
                }
            });
        });

        // 외부 클릭시 드롭다운 닫기
        document.addEventListener('click', function(e) {
            if (!languageBtn.contains(e.target) && !languageDropdown.contains(e.target)) {
                languageDropdown.classList.remove('active');
                languageBtn.setAttribute('aria-expanded', 'false');
            }
        });
    } else {
        console.error('Language selector elements not found!');
    }

    // Reference button
    const referenceBtn = document.getElementById('referenceBtn');
    if (referenceBtn) {
        referenceBtn.addEventListener('click', showReferenceModal);
    }

    // Modal close
    const closeModal = document.getElementById('closeModal');
    const referenceModal = document.getElementById('referenceModal');
    
    if (closeModal) {
        closeModal.addEventListener('click', hideReferenceModal);
    }
    
    if (referenceModal) {
        referenceModal.addEventListener('click', function(e) {
            if (e.target === this) {
                hideReferenceModal();
            }
        });
    }

    // Keyboard navigation for modal
    document.addEventListener('keydown', function(e) {
        const modal = document.getElementById('referenceModal');
        if (modal && modal.style.display === 'block' && e.key === 'Escape') {
            hideReferenceModal();
        }
    });

    // Mode switch
    const modeSwitch = document.getElementById('modeSwitch');
    if (modeSwitch) {
        modeSwitch.addEventListener('click', function() {
            console.log('Mode switch clicked');
            isTextToMorse = !isTextToMorse;
            
            // Swap input and output values
            const inputArea = document.getElementById('inputArea');
            const outputArea = document.getElementById('outputArea');
            const tempValue = inputArea.value;
            inputArea.value = outputArea.value;
            outputArea.value = tempValue;
            
            updateUI();
            translateText();
        });
    }

    // Input area
    const inputArea = document.getElementById('inputArea');
    if (inputArea) {
        inputArea.addEventListener('input', function() {
            translateText();
            detectLanguage();
        });
    }

    // Action buttons
    const copyBtn = document.getElementById('copyBtn');
    const clearBtn = document.getElementById('clearBtn');
    const shareBtn = document.getElementById('shareBtn');
    const copyUrlBtn = document.getElementById('copyUrlBtn');
    const playBtn = document.getElementById('playBtn');
    
    if (copyBtn) copyBtn.addEventListener('click', copyOutput);
    if (clearBtn) clearBtn.addEventListener('click', clearAll);
    if (shareBtn) shareBtn.addEventListener('click', shareTranslation);
    if (copyUrlBtn) copyUrlBtn.addEventListener('click', copyShareUrl);
    if (playBtn) playBtn.addEventListener('click', playMorse);

    // Speed slider
    const speedSlider = document.getElementById('speedSlider');
    if (speedSlider) {
        speedSlider.addEventListener('input', function() {
            const speedValue = document.getElementById('speedValue');
            if (speedValue) {
                speedValue.textContent = this.value;
            }
        });
    }
    
    console.log('Event listeners setup complete');
}

function showReferenceModal() {
    console.log('Showing reference modal...');
    const modal = document.getElementById('referenceModal');
    const content = document.getElementById('codebookContent');
    
    if (!modal || !content) {
        console.error('Modal elements not found');
        return;
    }
    
    content.innerHTML = '';
    
    Object.entries(morseCodeTables).forEach(([key, table]) => {
        const section = document.createElement('div');
        section.className = 'codebook-section';
        
        const title = document.createElement('h3');
        title.className = 'codebook-title';
        title.textContent = table.title;
        section.appendChild(title);
        
        const grid = document.createElement('div');
        grid.className = 'codebook-grid';
        
        Object.entries(table.codes).forEach(([char, morse]) => {
            const item = document.createElement('div');
            item.className = 'code-item';
            
            const charSpan = document.createElement('span');
            charSpan.className = 'code-char';
            charSpan.textContent = char;
            
            const morseSpan = document.createElement('span');
            morseSpan.className = 'code-morse';
            morseSpan.textContent = morse;
            
            item.appendChild(charSpan);
            item.appendChild(morseSpan);
            grid.appendChild(item);
        });
        
        section.appendChild(grid);
        content.appendChild(section);
    });
    
    modal.style.display = 'block';
    modal.setAttribute('aria-hidden', 'false');
    document.getElementById('closeModal').focus();
}

function hideReferenceModal() {
    const modal = document.getElementById('referenceModal');
    if (modal) {
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.getElementById('referenceBtn').focus();
    }
}

function updateUI() {
    console.log('Updating UI for language:', currentLang);
    const t = translations[currentLang];
    if (!t) {
        console.error('Translation not found for language:', currentLang);
        return;
    }

    // Update text elements safely
    const elements = {
        'title': t.title,
        'subtitle': t.subtitle,
        'inputLabel': t.inputLabel,
        'outputLabel': t.outputLabel,
        'modeText': isTextToMorse ? t.modeTextToMorse : t.modeMorseToText,
        'playText': t.playText,
        'copyText': t.copyText,
        'clearText': t.clearText,
        'shareText': t.shareText,
        'shareTitle': t.shareTitle,
        'copyUrlText': t.copyUrlText,
        'downloadTitle': t.downloadTitle,
        'downloadDescription': t.downloadDescription,
        'downloadText': t.downloadText,
        'speedLabel': t.speedLabel,
        'referenceText': t.referenceText,
        'modalTitle': t.modalTitle
    };

    Object.entries(elements).forEach(([id, text]) => {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = text;
        } else {
            console.warn(`Element with id '${id}' not found`);
        }
    });

    // Update placeholder
    const inputArea = document.getElementById('inputArea');
    if (inputArea) {
        inputArea.placeholder = isTextToMorse ? t.placeholder : t.morsePlaceholder;
    }

    // Update document properties
    document.documentElement.lang = currentLang;
    document.title = t.title;
    
    console.log('UI update complete');
}

function detectLanguage() {
    const inputArea = document.getElementById('inputArea');
    const detectedLanguage = document.getElementById('detectedLanguage');
    
    if (!inputArea || !detectedLanguage) return;
    
    const text = inputArea.value;
    if (!text.trim()) {
        detectedLanguage.textContent = '';
        return;
    }

    for (const [lang, pattern] of Object.entries(languagePatterns)) {
        if (pattern.test(text)) {
            const t = translations[currentLang];
            if (t) {
                detectedLanguage.textContent = t.detectedLang + getLanguageName(lang);
            }
            return;
        }
    }
}

function translateText() {
    const inputArea = document.getElementById('inputArea');
    const outputArea = document.getElementById('outputArea');
    
    if (!inputArea || !outputArea) return;
    
    const input = inputArea.value;

    if (isTextToMorse) {
        outputArea.value = textToMorse(input);
    } else {
        outputArea.value = morseToText(input);
    }
}

function decomposeKorean(char) {
    const code = char.charCodeAt(0);
    if (code >= 0xAC00 && code <= 0xD7A3) {
        const base = code - 0xAC00;
        const cho = Math.floor(base / 588);
        const jung = Math.floor((base % 588) / 28);
        const jong = base % 28;
        
        const choSeong = ['ㄱ','ㄲ','ㄴ','ㄷ','ㄸ','ㄹ','ㅁ','ㅂ','ㅃ','ㅅ','ㅆ','ㅇ','ㅈ','ㅉ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ'];
        const jungSeong = ['ㅏ','ㅐ','ㅑ','ㅒ','ㅓ','ㅔ','ㅕ','ㅖ','ㅗ','ㅘ','ㅙ','ㅚ','ㅛ','ㅜ','ㅝ','ㅞ','ㅟ','ㅠ','ㅡ','ㅢ','ㅣ'];
        const jongSeong = ['','ㄱ','ㄲ','ㄳ','ㄴ','ㄵ','ㄶ','ㄷ','ㄹ','ㄺ','ㄻ','ㄼ','ㄽ','ㄾ','ㄿ','ㅀ','ㅁ','ㅂ','ㅄ','ㅅ','ㅆ','ㅇ','ㅈ','ㅊ','ㅋ','ㅌ','ㅍ','ㅎ'];
        
        let result = '';
        if (choSeong[cho]) result += choSeong[cho];
        if (jungSeong[jung]) result += jungSeong[jung];
        if (jong > 0 && jongSeong[jong]) result += jongSeong[jong];
        
        return result;
    }
    return char;
}

function textToMorse(text) {
    let result = '';
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        if (char === ' ') {
            result += ' / ';
        } else if (/[가-힣]/.test(char)) {
            const decomposed = decomposeKorean(char);
            for (const jamo of decomposed) {
                if (morseCode[jamo]) {
                    result += morseCode[jamo] + ' ';
                }
            }
            result += '| '; // Syllable separator
        } else {
            const upperChar = char.toUpperCase();
            if (morseCode[upperChar]) {
                result += morseCode[upperChar] + ' ';
            } else {
                result += char + ' ';
            }
        }
    }
    return result.trim();
}

function morseToText(morse) {
    const words = morse.split(' / ');
    return words.map(word => {
        const syllables = word.split(' | ');
        return syllables.map(syllable => {
            const codes = syllable.trim().split(/\s+/);
            return codes.map(code => {
                return reverseMorseCode[code] || code;
            }).join('');
        }).join('');
    }).join(' ');
}

function copyOutput() {
    const outputArea = document.getElementById('outputArea');
    if (!outputArea) return;
    
    outputArea.select();
    outputArea.setSelectionRange(0, 99999);
    
    try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(outputArea.value).then(() => {
                showNotification('Copied!');
                outputArea.classList.add('success-animation');
                setTimeout(() => {
                    outputArea.classList.remove('success-animation');
                }, 600);
            }).catch(() => {
                // Fallback to execCommand
                if (document.execCommand('copy')) {
                    showNotification('Copied!');
                }
            });
        } else {
            // Fallback for older browsers
            if (document.execCommand('copy')) {
                showNotification('Copied!');
            }
        }
    } catch (err) {
        console.error('Copy failed:', err);
        showNotification('Copy failed');
    }
}

function showNotification(message) {
    const copyBtn = document.getElementById('copyBtn');
    if (!copyBtn) return;
    
    const originalHtml = copyBtn.innerHTML;
    copyBtn.innerHTML = `<i class="fas fa-check" aria-hidden="true"></i> ${message}`;
    setTimeout(() => {
        copyBtn.innerHTML = originalHtml;
    }, 2000);
}

function clearAll() {
    const inputArea = document.getElementById('inputArea');
    const outputArea = document.getElementById('outputArea');
    const detectedLanguage = document.getElementById('detectedLanguage');
    const shareSection = document.getElementById('shareSection');
    
    if (inputArea) inputArea.value = '';
    if (outputArea) outputArea.value = '';
    if (detectedLanguage) detectedLanguage.textContent = '';
    if (shareSection) shareSection.style.display = 'none';
    if (inputArea) inputArea.focus();
}

function shareTranslation() {
    const inputArea = document.getElementById('inputArea');
    const outputArea = document.getElementById('outputArea');
    
    if (!inputArea || !outputArea) return;
    
    const input = inputArea.value;
    const output = outputArea.value;
    
    if (!input.trim() && !output.trim()) {
        alert('Please enter some text to share!');
        return;
    }

    const shareData = {
        input: input,
        output: output,
        mode: isTextToMorse ? 'text' : 'morse',
        lang: currentLang
    };

    try {
        const encodedData = btoa(encodeURIComponent(JSON.stringify(shareData)));
        const shareUrl = `${window.location.origin}${window.location.pathname}?data=${encodedData}`;
        
        const shareUrlInput = document.getElementById('shareUrl');
        const shareSection = document.getElementById('shareSection');
        
        if (shareUrlInput) shareUrlInput.value = shareUrl;
        if (shareSection) shareSection.style.display = 'block';
    } catch (e) {
        alert('Failed to create share URL. Please try again.');
        console.error('Share error:', e);
    }
}

function copyShareUrl() {
    const shareUrl = document.getElementById('shareUrl');
    if (!shareUrl) return;
    
    shareUrl.select();
    shareUrl.setSelectionRange(0, 99999);
    
    try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(shareUrl.value).then(() => {
                showShareNotification('Copied!');
            }).catch(() => {
                if (document.execCommand('copy')) {
                    showShareNotification('Copied!');
                }
            });
        } else {
            if (document.execCommand('copy')) {
                showShareNotification('Copied!');
            }
        }
    } catch (err) {
        console.error('Copy failed:', err);
    }
}

function showShareNotification(message) {
    const copyUrlBtn = document.getElementById('copyUrlBtn');
    if (!copyUrlBtn) return;
    
    const originalHtml = copyUrlBtn.innerHTML;
    copyUrlBtn.innerHTML = `<i class="fas fa-check" aria-hidden="true"></i> ${message}`;
    setTimeout(() => {
        copyUrlBtn.innerHTML = originalHtml;
    }, 2000);
}

function loadFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const data = urlParams.get('data');
    
    if (data) {
        try {
            const shareData = JSON.parse(decodeURIComponent(atob(data)));
            currentLang = shareData.lang || 'en';
            isTextToMorse = shareData.mode === 'text';
            
            const inputArea = document.getElementById('inputArea');
            const outputArea = document.getElementById('outputArea');
            const currentLangElement = document.getElementById('currentLang');
            
            if (inputArea) inputArea.value = shareData.input || '';
            if (outputArea) outputArea.value = shareData.output || '';
            if (currentLangElement) currentLangElement.textContent = getLanguageName(currentLang);
            
            updateUI();
            detectLanguage();
        } catch (e) {
            console.error('Failed to load shared data:', e);
        }
    }
}

function playMorse() {
    if (isPlaying) {
        stopMorsePlayback();
        return;
    }
    
    const outputArea = document.getElementById('outputArea');
    const inputArea = document.getElementById('inputArea');
    
    if (!outputArea || !inputArea) return;
    
    const morseText = isTextToMorse ? outputArea.value : inputArea.value;
    
    if (!morseText.trim()) {
        alert('Please enter some text to generate Morse code first!');
        return;
    }
    
    isPlaying = true;
    const playBtn = document.getElementById('playBtn');
    const originalHtml = playBtn ? playBtn.innerHTML : '';
    
    if (playBtn) {
        playBtn.innerHTML = '<i class="fas fa-stop" aria-hidden="true"></i> Stop';
    }
    
    playMorseAudio(morseText).then(() => {
        isPlaying = false;
        if (playBtn) playBtn.innerHTML = originalHtml;
    }).catch(() => {
        isPlaying = false;
        if (playBtn) playBtn.innerHTML = originalHtml;
    });
}

function stopMorsePlayback() {
    isPlaying = false;
    
    if (currentToneTimeout) {
        clearTimeout(currentToneTimeout);
        currentToneTimeout = null;
    }
    
    if (currentOscillator) {
        try {
            currentOscillator.stop();
            currentOscillator.disconnect();
        } catch (e) {
            // Oscillator might already be stopped
        }
        currentOscillator = null;
    }
    
    const playBtn = document.getElementById('playBtn');
    const t = translations[currentLang] || translations['en'];
    if (playBtn) {
        playBtn.innerHTML = `<i class="fas fa-play" aria-hidden="true"></i> ${t.playText}`;
    }
}

async function playMorseAudio(morseText) {
    try {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        const speedSlider = document.getElementById('speedSlider');
        const speed = speedSlider ? parseInt(speedSlider.value) : 5;
        const dotDuration = 1200 / speed;
        const dashDuration = dotDuration * 3;
        const pauseDuration = dotDuration;
        const letterPauseDuration = dotDuration * 3;
        const wordPauseDuration = dotDuration * 7;
        
        const frequency = 600;
        
        for (let i = 0; i < morseText.length && isPlaying; i++) {
            const char = morseText[i];
            
            if (!isPlaying) break;
            
            if (char === '.') {
                await playTone(frequency, dotDuration);
                if (isPlaying) await sleep(pauseDuration);
            } else if (char === '-') {
                await playTone(frequency, dashDuration);
                if (isPlaying) await sleep(pauseDuration);
            } else if (char === ' ') {
                await sleep(letterPauseDuration);
            } else if (char === '/') {
                await sleep(wordPauseDuration);
            }
        }
    } catch (e) {
        console.error('Audio playback error:', e);
        throw e;
    }
}

function playTone(frequency, duration) {
    return new Promise((resolve) => {
        if (!isPlaying) {
            resolve();
            return;
        }
        
        try {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            currentOscillator = oscillator;
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.01);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + duration / 1000 - 0.01);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration / 1000);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
            
            oscillator.onended = () => {
                currentOscillator = null;
                resolve();
            };
            
            currentToneTimeout = setTimeout(() => {
                currentOscillator = null;
                resolve();
            }, duration);
        } catch (e) {
            console.error('Tone playback error:', e);
            currentOscillator = null;
            resolve();
        }
    });
}

function sleep(ms) {
    return new Promise(resolve => {
        if (!isPlaying) {
            resolve();
            return;
        }
        currentToneTimeout = setTimeout(resolve, ms);
    });
}

// Create floating particles
function createParticles() {
    const particlesContainer = document.getElementById('particles');
    if (!particlesContainer) return;
    
    const particleCount = 40;

    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 15 + 's';
        particle.style.animationDuration = (Math.random() * 10 + 15) + 's';
        particlesContainer.appendChild(particle);
    }
    
    console.log('Particles created');
}
